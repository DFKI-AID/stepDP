<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hello There</title>
    <meta name="description" content="Hello!">
    <meta name="author" content="Yannick KÃ¶rber">
    <link rel="stylesheet" type="text/css" href="/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/hello.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link rel="manifest" href="/manifest.json">
</head>


<div id="app" class="container-fluid">
    <div class="row">
        <div id="graphContainer"
             style="position:relative;overflow:hidden;width:600px;height:600px;background-color: lightgray;cursor:default;">
        </div>
    </div>
</div>


<!--<body onload="main(document.getElementById('graphContainer'))">-->
<body>

<script src="/jquery-3.3.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.22/dist/vue.js"></script>
<script src="/bootstrap.min.js"></script>
<script type="text/javascript">
    mxBasePath = 'graph/mxgraph';
</script>
<script src="/graph/mxgraph/js/mxClient.js"></script>
<script>
    const app = new Vue({
            el: '#app',
            data: {
                interval: null,
                statechart: null,
            },
            methods: {
                updateData: function () {
                    $.get('/behavior/task_behavior', function (response) {
                        this.statechart = response;
                        var container = $("#graphContainer")[0];
                        this.drawStateChart(container, this.statechart.root);
                    }.bind(this));
                },
                drawStateChart: function (container, statechart) {
                    // Checks if the browser is supported
                    if (!mxClient.isBrowserSupported()) {
                        // Displays an error message if the browser is not supported.
                        mxUtils.error('Browser is not supported!', 200, false);
                    } else {
                        // Disables the built-in context menu
                        mxEvent.disableContextMenu(container);

                        // Creates the graph inside the given container
                        var graph = new mxGraph(container);

                        // Enables rubberband selection
                        new mxRubberband(graph);

                        // Gets the default parent for inserting new cells. This
                        // is normally the first child of the root (ie. layer 0).
                        var parent = graph.getDefaultParent();

                        var context = {};
                        context.graph = graph;
                        context.bbox = {minx: 0, miny: 0, maxx: 0, maxy: 0};
                        this.getBoundingBox(context, statechart);
                        console.log(context.bbox);
                        context.vertices = {};


                        // Adds cells to the model in a single step
                        graph.getModel().beginUpdate();
                        try {
                            this.drawState(context, parent, statechart);
                            this.drawTransitions(context, parent, statechart);
                            // var v1 = graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30);
                            // var v2 = graph.insertVertex(parent, null, 'World!', 200, 150, 80, 30);
                            // var e1 = graph.insertEdge(parent, null, '', v1, v2);
                        } finally {
                            // Updates the display
                            graph.getModel().endUpdate();
                        }

                        // var encoder = new mxCodec();
                        // var node = encoder.encode(v1);
                        // console.log(mxUtils.getXml(node));
                    }
                },

                drawState: function (context, parent, state) {
                    var geo = state.geometry;
                    if (geo == null) {
                        geo = {x: 0, y: 0, w: 50, h: 50};
                    }
                    var vertex = context.graph.insertVertex(parent, null, state.id,
                        geo.x - context.bbox.minx,
                        geo.y - context.bbox.miny,
                        geo.w,
                        geo.h
                    );
                    context.vertices[state.id] = vertex;

                    for (var i = 0; i < state.children.length; ++i) {
                        var childState = state.children[i];
                        this.drawState(context, parent, childState);
                    }
                },

                drawTransitions: function (context, parent, state) {

                    for (var i = 0; i < state.transitions.length; ++i) {
                        var transition = state.transitions[i];
                        var v1 = context.vertices[state.id];
                        var v2 = context.vertices[transition.target];
                        var e1 = context.graph.insertEdge(parent, null, '', v1, v2);
                    }

                    for (var i = 0; i < state.children.length; ++i) {
                        var childState = state.children[i];
                        this.drawTransitions(context, parent, childState);
                    }
                },

                getBoundingBox: function (context, state) {
                    var geo = state.geometry;
                    if (geo != null) {
                        context.bbox.minx = Math.min(context.bbox.minx, geo.x);
                        context.bbox.miny = Math.min(context.bbox.miny, geo.y);
                        context.bbox.maxx = Math.max(context.bbox.minx, geo.x + geo.w);
                        context.bbox.maxy = Math.max(context.bbox.miny, geo.y + geo.h);
                    }
                    for (var i = 0; i < state.children.length; ++i) {
                        var childState = state.children[i];
                        this.getBoundingBox(context, childState);
                    }
                }

            },
            created() {
                this.updateData();
                this.interval = setInterval(function () {
                    this.updateData();
                }.bind(this), 20000);

            }

        })
    ;


</script>


<script type="text/javascript" ;>


    // function main(container) {
    //     // Checks if the browser is supported
    //     if (!mxClient.isBrowserSupported()) {
    //         // Displays an error message if the browser is not supported.
    //         mxUtils.error('Browser is not supported!', 200, false);
    //     } else {
    //         // Disables the built-in context menu
    //         mxEvent.disableContextMenu(container);
    //
    //         // Creates the graph inside the given container
    //         var graph = new mxGraph(container);
    //
    //         // Enables rubberband selection
    //         new mxRubberband(graph);
    //
    //         // Gets the default parent for inserting new cells. This
    //         // is normally the first child of the root (ie. layer 0).
    //         var parent = graph.getDefaultParent();
    //
    //         // Adds cells to the model in a single step
    //         graph.getModel().beginUpdate();
    //         try {
    //             var v1 = graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30);
    //             var v2 = graph.insertVertex(parent, null, 'World!', 200, 150, 80, 30);
    //             var e1 = graph.insertEdge(parent, null, '', v1, v2);
    //         } finally {
    //             // Updates the display
    //             graph.getModel().endUpdate();
    //         }
    //
    //         var encoder = new mxCodec();
    //         var node = encoder.encode(v1);
    //         console.log(mxUtils.getXml(node));
    //     }
    // }
</script>

</body>

</html>